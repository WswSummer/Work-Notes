docker

![image](https://user-images.githubusercontent.com/34562805/102065738-e7e91b00-3e33-11eb-8832-0d1f02ae8074.png)

Dockerfile文件中的保留关键字：

![image](https://user-images.githubusercontent.com/34562805/102065787-f8999100-3e33-11eb-8f09-d38afe04fe65.png)

![image](https://user-images.githubusercontent.com/34562805/102065862-09e29d80-3e34-11eb-96e4-e02b6a59d1f9.png)

***

Java中**this**的作用：

1. 区分局部变量和成员变量
2. 代表当前对象的实例
3. 构造函数

***

@SuppressWarnings("unchecked") 告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息。

***

null写在==的前面和后面的区别：

在java中: 当a = null的时候，if (a == null){ ... } 或者 if ( null == a){ ... }都是可以正常运行的。 出现这种写法的原因是在C语言中出现的，在C语言中 if (a = null) { ... } 【少敲打一个符号 ‘=’的情况下】编译不会报错，但是写成 if (null = a){ ... }编译就会报错。所以在C语言中会鼓励程序员使用 null == a 来进行判断。

null放在前面是为了避免少写一个"=","null="书写会报错，防止笔误写成"=null"时检查不出来；为了防止笔误，也为了代码规范所以还是将null放在前面进行判断更好。

" "写在equals的前面和后面的区别：

a.quals("")和"".equals(a)，避免引起空指针异常。

***

@Builder声明实体，它提供在设计数据实体时，对外保持private setter，而对属性的赋值采用Builder的方式，这种方式最优雅，也更符合封装的原则，不对外公开属性的写操作！

```java
@Builder(toBuilder = true)
@Getter
public class UserInfo {
```

@Builder注解修改原对象的属性值

修改实体，要求实体上添加@Builder(toBuilder=true)

***

![image](https://user-images.githubusercontent.com/34562805/102744137-1024cc80-4394-11eb-979a-5d2267c8809a.png)

POJO：简单java对象、原生对象

VO：view object 视图对象 展示HTML JSP用，但是现在用Entity

DTO：data transfer object 数据传输对象

Entity：实体类 数据库 ORM 对象关系映射

domain：领域模型 用户User 银行病人 领域涉及比较难，需要对行业有认识

***

```java
public void lock() {
    synchronized (this) {
        try {
            this.wait();
        } catch (InterruptedException e) {
            log.error(e.getMessage(), e);
        }
    }
}

public void unlock() {
    synchronized (this) {
        this.notifyAll();
    }
}
```

**什么场景需要用到分布式锁**

多台服务器做同一件事情。要抢着用， 那么用分布式锁， 前面的人用完了你才可以进去，或者是前面的人用完了你就可以走了。 简单的来说，你可以写一个项目，项目写一个定时任务，每天 10 点 34 分跑一次发一次右键， 用两台服务器部署，不用分布式锁，那么你的定时任务可能会跑两次，但是实际上你只需要跑一次。用分布式锁锁上以后，你的代码只会跑一次。

一般来说分布式锁跟负载均衡是一起出现的，如果有多个机器在同一时间会去做一样的事情，就需要锁 例如负载均衡的情况下给用户发短信，用户短时间内请求了多次，第一次如果没有锁的话可能数据库里的标识没有被修改为已发送就被第二次读取了，这样用户就会收到 N 条短信

集群环境用

JVM 锁 synchronized 、Lockd 这些只对单个 jvm 环境内有效。  只部署 1 台服务，jvm 锁能保证两个请求不并发处理  如果同时部署多台服务，如果两个请求分别被发送到两个服务上，这时候 jvm 锁就不能限制了

锁是用来解决并发问题的，分布式锁自然是解决分布式系统中的并发问题。 比如分布式限流、幂等处理…

1.集群中视频、文档转换，同一个文件同时只有一个服务转，不要重复转，避免浪费资源 2. 支持并行任务的作业系统，某个任务结束后，要修改所有后继任务的入度，执行可以开始执行的任务，也是用分布式锁保证同一个作业的原子性操作

锁是解决资源竞争问题的，分布式锁就是解决分布式环境下多个程序竞争一个资源的问题。例如支付，购物，订单等共享独占资源

服务需要执行某个 job，但是服务被部署成多个实例（需要负载均衡嘛），但是这个 job 只能起一个线程去 run，就用到了所谓的分布式锁；多个线程需要去抢这个 job 去执行，就需要锁。在支持线程操作的语言里，锁就是锁，上升到服务层面（也就是加一层网络，线程分布在多机器上）就叫分布式锁了

***

idea快捷键

|      快捷键      |                             介绍                             |
| :--------------: | :----------------------------------------------------------: |
|   Alt + Insert   | 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备） |
|     Ctrl + [     |            移动光标到当前所在代码的花括号开始位置            |
|     Ctrl + O     |                       选择可重写的方法                       |
|     Ctrl + I     |                       选择可继承的方法                       |
|     Ctrl + H     |                     显示当前类的层次结构                     |
|     Ctrl + Q     | 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 |
|     Ctrl + F     |               在当前文件进行文本查找 （必备）                |
|  Alt + 左方向键  | 切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备） |
|  Alt + 前方向键  |      当前光标跳转到当前文件的前一个方法名位置 （必备）       |
|  Ctrl + Alt + L  |     格式化代码，可以对当前文件和整个包目录使用 （必备）      |
|  Ctrl + Alt + B  |   在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口   |
| Ctrl + Shift + C |            复制当前文件磁盘路径到剪贴板 （必备）             |
|  ctrl + alt + <  |                          回到上一步                          |

系统架构：

https://segmentfault.com/a/1190000018626163

***

React项目创建：

npx create-react-app my-app

运行:

npm start

